= data.structs.first.namespace.map{|ns| "module #{type ns}"}.join($/)
= data.structs.first.namespace.map{|ns| "end # #{type ns}"}.join($/)

- data.types.each do |type|
  - case type
  - when Protocol::Enum
    module #{class_case type.namespace}::#{type type.name}
      - type.members.each do |k, v|
        = '%s = %s;' % [constant(k), v.to_i]
      - end
    end

  - when Protocol::Struct
    class #{class_case type.namespace}::#{type type.name} < ::Struct.new(#{struct_members type.members})
      FORMAT = #{struct_members_format(type.members).dump}.freeze

      def self.load string
        result = new(*string.unpack(FORMAT))
        - type.members.each_with_index do |m, i|
          - if m.kind_of?(Protocol::User) and m.klass.kind_of?(Protocol::Struct)
            result.#{m.name} = #{class_case m.klass.namespace}::#{type m.klass.name}.load(result.#{m.name})
          - elsif m.kind_of?(Protocol::Bool)
            result.#{m.name} = result.#{m.name} == 1 ? true : false
          - end
        - end
        result
      end

      def dump
        result = to_a
        - type.members.each_with_index do |m, i|
          - if m.kind_of?(Protocol::User) and m.klass.kind_of?(Protocol::Struct)
            result[#{i}] = self.#{m.name}.dump unless self.#{m.name}.nil?
          - elsif m.kind_of?(Protocol::Bool)
            result[#{i}] = self.#{m.name} ? 1 : 0
          - end
        - end
        result.pack(FORMAT)
      end
    end

  - end
- end
